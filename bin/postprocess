#!/usr/bin/env ruby
# frozen_string_literal: true

require 'csv'
require 'thor'
require 'yajl'
require_relative '../lib/config'
require_relative '../lib/transformation'

class Postprocess < Thor
  desc 'process', 'Process the data to be imported into Senzing'
  option :config, desc: 'Path to the configuration file for this data set',
                 default: File.expand_path(File.join(__dir__, '../config/config.yml'))
  option :input, desc: 'Path to the file to be processed',
                 default: File.join(Dir.getwd, 'senzing_output.json')
  option :output, desc: 'Path to the file that will be output after processing',
                  default: File.join(Dir.getwd, 'people_matches.csv')
  def process
    config = Config.from_file(options[:config])

    potentials = {}
    entities = {}
    Yajl::Parser.parse(File.open(options[:input]), symbolize_keys: true) do |entity|
      entity_id = entity[:RESOLVED_ENTITY][:ENTITY_ID]
      entities[entity_id] ||= []

      entity[:RESOLVED_ENTITY][:RECORDS].each do |record|
        record[:ENTITY_ID] = entity_id
        Transformation::transform(config, record)

        # TODO: Format into a hash to include in the array.
        output = {}
        config.field_map[:post].each do |field, map|
          output[map] = record[field]
        end

        entities[entity_id] << output
      end

      entity[:RELATED_ENTITIES].each do |related|
        # TODO: Does MATCH_SCORE ever get set?
        next unless related[:MATCH_LEVEL] <= config.match_level && related[:MATCH_SCORE].to_i >= config.match_score

        potentials[related[:ENTITY_ID]] ||= {}
        potentials[related[:ENTITY_ID]][entity[:ENTITY_ID]] = related[:MATCH_SCORE].to_i
      end
    end

    csv_options = {
      headers: config.field_map[:post].values,
      write_headers: true
    }
    CSV.open(options[:output], 'w', **csv_options) do |csv|
      # TODO: Add partials to the truth set so we can verify this behavior.
      # potentials.each do |entity_id, related|
      #   person_id, match_score = related.max_by { |_k, v| v }
      #
      #   entities[entity_id].each do |record|
      #     original_person_id, db, party_num, original_score = record.split(',')
      #     output.puts "#{person_id},#{db},#{party_num},#{original_score},#{original_person_id},#{match_score}"
      #     entities[person_id] << "#{person_id},#{db},#{party_num},#{original_score},#{original_person_id},#{match_score}"
      #   end
      # end
      #
      # potentials.keys.each { |potential_person_id| entities.delete(potential_person_id) }

      entities.values.each do |records|
        records.each { |record| csv << record }
      end
    end

    say_status('success', "Contents output to #{options[:output]}")
  end
end

Postprocess.start(ARGV)
